{
  "hash": "60c83ce878be61c2de15d1cb71797d7f",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Parallelizing a Python Process to Build a Stacked ACS DataFrame\"\ndescription: \"This post demonstrates how to take a standard list comprehension of calls to the Census API and parallelize it for dramatic time savings.\"\ndate: 2025-08-05\nauthor:\n    - name: Lance Couzens\n      url: https://mostlyunoriginal.github.io  \ncategories: [Python, Parallelization]\ncitation: \n  url: https://mostlyunoriginal.github.io/posts/2025-08-05-Parallelizing-a-Python-for-loop/\nimage: Preview.png\ndraft: true\nlightbox: true\nparams:\n    year: 2023\n---\n\n\n## Background\n\nAs part of a machine learning class I've been building for a client, I've provided the option to join county-level ACS estimates onto the training and prediction data. County data require state-level calls to the Census API, and including all states and a few years, sequential pulls were proving to be a significant bottleneck. Swapping the sequential process out in favor of a parallel one yielded dramatic time savings. This post demonstrates that change via an abstracted, simplified example.\n\n## Data Ingestion\n\nThe `get_acs` function pulls county-level 5-year ACS estimates from the Census API for a single state and year. We also do all the importing and environment variable creation we'll need for both versions of subsequent steps (we want those to be as close to apples-to-apples as possible since we'll be comparing timing).\n\n::: {#580f881f .cell execution_count=1}\n``` {.python .cell-code}\nimport requests\nimport polars as pl\nimport os\nimport itertools as it\nimport us\nfrom dotenv import load_dotenv\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\n\nload_dotenv()\n\n# states and years to pull ACS 5-year county-level estimates for\nstates = [state.fips for state in us.states.STATES]\nyears = [2020, 2021]\n\n# list of tuples representing cartesian product of individual state and year lists\nstate_year_pairs = list(it.product(states, years))\n\ndef get_acs(\n    state_fips: str, \n    year: int,\n    api_key: str = None, \n    acs_vars: dict = {\n            \"B01001_001E\": \"pop_total\",\n            \"B01002_001E\": \"median_age\",\n            \"B19013_001E\": \"med_hh_income\",\n            \"B23025_005E\": \"unemployed\",\n            \"B25077_001E\": \"med_home_value\",\n            \"B25064_001E\": \"med_rent\",\n        }\n    ):\n\n    url = (\n        f\"https://api.census.gov/data/{year}/acs/\"\n        f\"acs5?get={','.join(acs_vars.keys())}\"\n        f\"&for=county:*&in=state:{state_fips}\"\n        f\"&key={api_key}\"\n    )\n\n    # issue request and parse resulting json\n    try:\n        response = requests.get(url)\n        response.raise_for_status()\n        data = response.json()\n        if len(data)>1:\n            acs_df = pl.DataFrame(\n                data[1:], \n                schema=data[0],\n                orient=\"row\",\n            ).rename(acs_vars).with_columns(year=pl.lit(year))\n            return acs_df\n    except requests.exceptions.RequestException as e:\n        print(f\"Error: {e}\")\n\n    return None\n```\n:::\n\n\n## Implementation via sequential list comprehension\n\nHere we grab and stack the data for all states and two data years via list comprehension.\n\n::: {#62f50440 .cell execution_count=2}\n``` {.python .cell-code}\n%%time\n\nall_acs = [\n    get_acs(state_fips, year, api_key=os.getenv(\"CENSUS_API_KEY\"))\n    for state_fips, year in state_year_pairs\n]\n\n# concatenate all results\nif all_acs:\n    stacked_acs = pl.concat(all_acs)\n    print(stacked_acs)\nelse:\n    print(\"No data was fetched.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nshape: (6_284, 9)\n┌───────────┬────────────┬───────────────┬────────────┬───┬──────────┬───────┬────────┬──────┐\n│ pop_total ┆ median_age ┆ med_hh_income ┆ unemployed ┆ … ┆ med_rent ┆ state ┆ county ┆ year │\n│ ---       ┆ ---        ┆ ---           ┆ ---        ┆   ┆ ---      ┆ ---   ┆ ---    ┆ ---  │\n│ str       ┆ str        ┆ str           ┆ str        ┆   ┆ str      ┆ str   ┆ str    ┆ i32  │\n╞═══════════╪════════════╪═══════════════╪════════════╪═══╪══════════╪═══════╪════════╪══════╡\n│ 55639     ┆ 38.6       ┆ 57982         ┆ 736        ┆ … ┆ 1011     ┆ 01    ┆ 001    ┆ 2020 │\n│ 218289    ┆ 43.2       ┆ 61756         ┆ 4027       ┆ … ┆ 1032     ┆ 01    ┆ 003    ┆ 2020 │\n│ 25026     ┆ 40.1       ┆ 34990         ┆ 649        ┆ … ┆ 587      ┆ 01    ┆ 005    ┆ 2020 │\n│ 22374     ┆ 39.9       ┆ 51721         ┆ 667        ┆ … ┆ 693      ┆ 01    ┆ 007    ┆ 2020 │\n│ 57755     ┆ 41.0       ┆ 48922         ┆ 1253       ┆ … ┆ 666      ┆ 01    ┆ 009    ┆ 2020 │\n│ …         ┆ …          ┆ …             ┆ …          ┆ … ┆ …        ┆ …     ┆ …      ┆ …    │\n│ 42459     ┆ 36.4       ┆ 76668         ┆ 1503       ┆ … ┆ 859      ┆ 56    ┆ 037    ┆ 2021 │\n│ 23319     ┆ 39.6       ┆ 94498         ┆ 368        ┆ … ┆ 1524     ┆ 56    ┆ 039    ┆ 2021 │\n│ 20514     ┆ 36.3       ┆ 75106         ┆ 348        ┆ … ┆ 711      ┆ 56    ┆ 041    ┆ 2021 │\n│ 7768      ┆ 42.7       ┆ 62271         ┆ 101        ┆ … ┆ 621      ┆ 56    ┆ 043    ┆ 2021 │\n│ 6891      ┆ 43.6       ┆ 65566         ┆ 126        ┆ … ┆ 726      ┆ 56    ┆ 045    ┆ 2021 │\n└───────────┴────────────┴───────────────┴────────────┴───┴──────────┴───────┴────────┴──────┘\nCPU times: total: 31.2 ms\nWall time: 1min 3s\n```\n:::\n:::\n\n\n## A Parallelized Alternative\n\nHere we leverage the `concurrent.futures` module from the standard Python library to issue all API calls simultaneously, gathering results asynchronously as they become available.\n\n::: {#eb686c0b .cell execution_count=3}\n``` {.python .cell-code}\n%%time\n\nall_acs = []\nwith ThreadPoolExecutor(max_workers=os.cpu_count()) as executor:\n    futures = {\n        executor.submit(\n          get_acs, \n          state_fips, \n          year, \n          api_key=os.getenv(\"CENSUS_API_KEY\")\n        ): (state_fips, year)\n        for state_fips, year in state_year_pairs\n    }\n    for future in as_completed(futures.keys()):\n        pair = futures[future]\n        try:\n          result = future.result()\n          if result is not None:\n              all_acs.append(result)\n        except Exception as e:\n          print(f\"ERROR: Something went wrong for state={pair[0]}, year={pair[1]}: {e}\")\n\n# concatenate all results\nif all_acs:\n    stacked_acs = pl.concat(all_acs)\n    print(stacked_acs)\nelse:\n    print(\"No data was fetched.\")            \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nshape: (6_284, 9)\n┌───────────┬────────────┬───────────────┬────────────┬───┬──────────┬───────┬────────┬──────┐\n│ pop_total ┆ median_age ┆ med_hh_income ┆ unemployed ┆ … ┆ med_rent ┆ state ┆ county ┆ year │\n│ ---       ┆ ---        ┆ ---           ┆ ---        ┆   ┆ ---      ┆ ---   ┆ ---    ┆ ---  │\n│ str       ┆ str        ┆ str           ┆ str        ┆   ┆ str      ┆ str   ┆ str    ┆ i32  │\n╞═══════════╪════════════╪═══════════════╪════════════╪═══╪══════════╪═══════╪════════╪══════╡\n│ 55639     ┆ 38.6       ┆ 57982         ┆ 736        ┆ … ┆ 1011     ┆ 01    ┆ 001    ┆ 2020 │\n│ 218289    ┆ 43.2       ┆ 61756         ┆ 4027       ┆ … ┆ 1032     ┆ 01    ┆ 003    ┆ 2020 │\n│ 25026     ┆ 40.1       ┆ 34990         ┆ 649        ┆ … ┆ 587      ┆ 01    ┆ 005    ┆ 2020 │\n│ 22374     ┆ 39.9       ┆ 51721         ┆ 667        ┆ … ┆ 693      ┆ 01    ┆ 007    ┆ 2020 │\n│ 57755     ┆ 41.0       ┆ 48922         ┆ 1253       ┆ … ┆ 666      ┆ 01    ┆ 009    ┆ 2020 │\n│ …         ┆ …          ┆ …             ┆ …          ┆ … ┆ …        ┆ …     ┆ …      ┆ …    │\n│ 42459     ┆ 36.4       ┆ 76668         ┆ 1503       ┆ … ┆ 859      ┆ 56    ┆ 037    ┆ 2021 │\n│ 23319     ┆ 39.6       ┆ 94498         ┆ 368        ┆ … ┆ 1524     ┆ 56    ┆ 039    ┆ 2021 │\n│ 20514     ┆ 36.3       ┆ 75106         ┆ 348        ┆ … ┆ 711      ┆ 56    ┆ 041    ┆ 2021 │\n│ 7768      ┆ 42.7       ┆ 62271         ┆ 101        ┆ … ┆ 621      ┆ 56    ┆ 043    ┆ 2021 │\n│ 6891      ┆ 43.6       ┆ 65566         ┆ 126        ┆ … ┆ 726      ┆ 56    ┆ 045    ┆ 2021 │\n└───────────┴────────────┴───────────────┴────────────┴───┴──────────┴───────┴────────┴──────┘\nCPU times: total: 0 ns\nWall time: 4.48 s\n```\n:::\n:::\n\n\nIn this alternative, `ThreadPoolExecutor` is used as a context manager to issue `get_acs` calls and \"future states\" are gathered via a dictionary comprehension. Note, however, that this dictionary flips the script a bit with the returned data frames in the key position and the state, year tuples they correspond to in the values position. This is possible because the returned data frames are unique / hashable, and it allows us to report out for which state and year a failure occurs.\n\nAs results are returned, they are assessed and appended to the `all_acs` list for subsequent concatenation. As shown by the `Wall time` under each code chunk, we see a significant speed up, roughly corresponding to the number of cores (16) available in the PC in which this post was rendered.\n\n",
    "supporting": [
      "index_files\\figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}