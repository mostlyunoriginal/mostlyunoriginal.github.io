{
  "hash": "83eb105111dffe0428857b25fb1ece55",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"cendat ver 0.4.4\"\ndescription: \"This post covers a recent performance upgrade.\"\ndate: 2025-08-26\nauthor:\n    - name: Lance Couzens\n      url: https://mostlyunoriginal.github.io  \ncategories: [Python, cendat, Census, API]\ncitation: \n  url: https://mostlyunoriginal.github.io/posts/2025-08-26-cendat-fully-wild/\nimage: logo.png \ndraft: false\nlightbox: true\n---\n\n# Full Utilization of Wildcards\n\nOne of the core strengths of `cendat` is concurrence–it can build, issue, and manage many API queries simultaneously. And up until `ver 0.4.4` that capability was especially critical because `cendat` brute-forced the geographic hierarchy, generating many small queries for deeply nested geographies to deliver data in a predictable and timely fashion. But, that brute force approach didn't make full use of the API's wildcard paradigm, which allows for queries that are generalized over parent geographies to return bigger data objects with fewer queries. Making use of this capability in a completely general tool like `cendat`, however, is tricky because the Census geographic hierarchy is complex and what works for one summary level may not work for another. Thankfully, the Census Bureau provides all of the necessary information, and this latest version can now make use of it.\n\nLet's take a look at an example JSON entry for the block group summary level in the 2023 ACS 5-year data product:\n\n``` json\n{\n  \"name\": \"block group\",\n  \"geoLevelDisplay\": \"150\",\n  \"referenceDate\": \"2023-01-01\",\n  \"requires\": [\n    \"state\",\n    \"county\",\n    \"tract\"\n  ],\n  \"wildcard\": [\n    \"county\",\n    \"tract\"\n  ],\n  \"optionalWithWCFor\": \"tract\"\n}\n```\n\nHere we can see that in order to query for block groups, an API query requires information on the parent state, county, and tract–that's what's indicated by `\"requires\": [ \"state\", \"county\", \"tract\" ]`. Prior to `0.4.4`, invoking `get_data()` with block groups set as the target geography yielded API calls that *explicitly* specified the nesting state, county, and tract. Again, these queries were issued concurrently and the individual data objects were small, so this was okay in many cases. But, for national queries, for example–where no nesting geographies are provided to limit the scope–this approach becomes problematic (there are \\~85k tracts in the U.S.).\n\nWe can do this job with far fewer pulls by utilizing the information in the `wildcard` and `optionalWithWCFor` fields. In the above entry we have `\"wildcard\": [ \"county\", \"tract\" ]` and `\"optionalWithWCFor\": \"tract\"`. That means that we really only have to provide state for national results because county and tract can be wildcarded and tract can be dropped altogether unless we need to specify specific tracts. Consider the following example in which we pull total population by block group for the whole nation and see how many of them have contain more than 10k people.\n\n::: {#987314cf .cell execution_count=1}\n``` {.python .cell-code}\n%%time\n\nimport os\nfrom cendat import CenDatHelper\nimport polars as pl\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\ncdh = CenDatHelper(key=os.getenv(\"CENSUS_API_KEY\"))\n\ncdh.list_products(patterns=r\"2023/acs/acs5\\)\")\ncdh.set_products()\ncdh.set_variables([\"B01001_001E\"])\ncdh.set_geos(\"150\")\nresponse = cdh.get_data()\n\nresponse.tabulate(\"state\", where=\"B01001_001E > 10_000\")\n\ndf = response.to_polars(concat=True, destring=True)\ndf.shape\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n✅ API key loaded successfully.\n✅ Product set: 'ACS 5-Year Detailed Tables (2023/acs/acs5)' (Vintage: [2023])\n✅ Variables set:\n  - Product: ACS 5-Year Detailed Tables (2023/acs/acs5) (Vintage: [2023])\n    Variables: B01001_001E\n✅ Geographies set: 'block group' (requires `within` for: county, state, tract)\n✅ Parameters created for 1 geo-variable combinations.\nℹ️ Discovering parent geographies for: ['state']\n✅ Found 52 combinations. Building API queries...\nℹ️ Making 52 API call(s)...\nshape: (9, 5)\n┌───────┬────┬──────┬──────┬────────┐\n│ state ┆  n ┆  pct ┆ cumn ┆ cumpct │\n╞═══════╪════╪══════╪══════╪════════╡\n│    06 ┆  4 ┆  8.9 ┆    4 ┆    8.9 │\n│    12 ┆ 13 ┆ 28.9 ┆   17 ┆   37.8 │\n│    24 ┆  1 ┆  2.2 ┆   18 ┆   40.0 │\n│    25 ┆  1 ┆  2.2 ┆   19 ┆   42.2 │\n│    32 ┆  1 ┆  2.2 ┆   20 ┆   44.4 │\n│    45 ┆  1 ┆  2.2 ┆   21 ┆   46.7 │\n│    48 ┆ 21 ┆ 46.7 ┆   42 ┆   93.3 │\n│    49 ┆  2 ┆  4.4 ┆   44 ┆   97.8 │\n│    51 ┆  1 ┆  2.2 ┆   45 ┆  100.0 │\n└───────┴────┴──────┴──────┴────────┘\nCPU times: user 2.25 s, sys: 271 ms, total: 2.52 s\nWall time: 11.6 s\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n(242296, 9)\n```\n:::\n:::\n\n\nNow we're down to 52 queries completed in about 10 seconds. And we can still have more complex nesting specifications as well:\n\n::: {#aa38528e .cell execution_count=2}\n``` {.python .cell-code}\n%%time\n\nresponse = cdh.get_data(\n    within=[\n        {'state': '08', 'county': '069', 'tract': ['002601', '002602', '002700']},\n        {'state': '56', 'county': '021'},\n        {'state': ['06', '48']},\n    ]\n)\n\nresponse.tabulate('state')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n✅ Parameters created for 1 geo-variable combinations.\n✅ Found 1 combinations. Building API queries...\n✅ Found 1 combinations. Building API queries...\n✅ Found 1 combinations. Building API queries...\n✅ Found 1 combinations. Building API queries...\n✅ Found 1 combinations. Building API queries...\n✅ Found 1 combinations. Building API queries...\nℹ️ Making 6 API call(s)...\nshape: (4, 5)\n┌───────┬────────┬──────┬────────┬────────┐\n│ state ┆      n ┆  pct ┆   cumn ┆ cumpct │\n╞═══════╪════════╪══════╪════════╪════════╡\n│    06 ┆ 25,607 ┆ 57.8 ┆ 25,607 ┆   57.8 │\n│    08 ┆      8 ┆  0.0 ┆ 25,615 ┆   57.8 │\n│    48 ┆ 18,638 ┆ 42.0 ┆ 44,253 ┆   99.8 │\n│    56 ┆     78 ┆  0.2 ┆ 44,331 ┆  100.0 │\n└───────┴────────┴──────┴────────┴────────┘\nCPU times: user 246 ms, sys: 30.6 ms, total: 276 ms\nWall time: 2.11 s\n```\n:::\n:::\n\n\nAnd we can combine different summary levels as well. Here we get data for states, counties, and county subdivisions:\n\n::: {#6cb2420b .cell execution_count=3}\n``` {.python .cell-code}\n%%time\n\ncdh.set_geos(['040', '050', '060'])\nresponse = cdh.get_data()\n\nresponse.tabulate('sumlev')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n✅ Geographies set: 'state', 'county' (requires `within` for: state), 'county subdivision' (requires `within` for: county, state)\n✅ Parameters created for 3 geo-variable combinations.\n✅ Found 1 combinations. Building API queries...\n✅ Found 1 combinations. Building API queries...\nℹ️ Discovering parent geographies for: ['state']\n✅ Found 52 combinations. Building API queries...\nℹ️ Making 54 API call(s)...\nshape: (3, 5)\n┌────────┬────────┬──────┬────────┬────────┐\n│ sumlev ┆      n ┆  pct ┆   cumn ┆ cumpct │\n╞════════╪════════╪══════╪════════╪════════╡\n│    040 ┆     52 ┆  0.1 ┆     52 ┆    0.1 │\n│    050 ┆  3,222 ┆  8.1 ┆  3,274 ┆    8.2 │\n│    060 ┆ 36,434 ┆ 91.8 ┆ 39,708 ┆  100.0 │\n└────────┴────────┴──────┴────────┴────────┘\nCPU times: user 511 ms, sys: 98.3 ms, total: 609 ms\nWall time: 7.41 s\n```\n:::\n:::\n\n\nThat's the last of my planned performance upgrades of core functionality, so (barring patches as of yet unforeseen) up next is feature expansion. First up is a biggie: optionally fetching polygons for requested geographies. Stay tuned...\n\n",
    "supporting": [
      "index_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}