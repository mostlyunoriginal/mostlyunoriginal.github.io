{
  "hash": "4b3844155bcf567630bce0470c1e3cfe",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"cendat ver 0.4.5\"\ndescription: \"Just when I said I was done for a while...\"\ndate: 2025-08-27\nauthor:\n    - name: Lance Couzens\n      url: https://mostlyunoriginal.github.io  \ncategories: [Python, cendat, Census, API]\ncitation: \n  url: https://mostlyunoriginal.github.io/posts/2025-08-27-now-with-names/\nimage: logo.png \ndraft: false\nlightbox: true\n---\n\n# Hi, It's Me Again...\n\nI didn't expect to be back here so soon, but I realized something was missing from `cendat`–the ability to get geography names. It didn't *seem* like it was missing, after all you can just include it in `set_names()`... right? Well, it turns out that you can't do that because `NAME` is a special keyword understood by the by the API but that is not included in `variables.json`, which is the basis for the selections you can make in `set_names()`.\n\nThankfully the fix for this is very simple: there is a new `include_names` parameter in `get_data()` (boolean, defaults to `False`) that we can use to include geography name in our queries. Like this:\n\n::: {#78da42e8 .cell execution_count=1}\n``` {.python .cell-code}\nimport os\nfrom cendat import CenDatHelper\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nc = CenDatHelper(key=os.getenv(\"CENSUS_API_KEY\"))\n\nc.list_products(2023, r\"acs/acs1\\)\")\nc.set_products()\nc.set_variables(\"B01001_001E\")\nc.set_geos(\"160\")\n\nresponse = c.get_data(include_names=True)\n\nresponse.tabulate(\"NAME\", where=\"B01001_001E > 1_000_000\", weight_var=\"B01001_001E\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n✅ API key loaded successfully.\n✅ Product set: 'ACS 1-Year Detailed Tables (2023/acs/acs1)' (Vintage: [2023])\n✅ Variables set:\n  - Product: ACS 1-Year Detailed Tables (2023/acs/acs1) (Vintage: [2023])\n    Variables: B01001_001E\n✅ Geographies set: 'place' (requires `within` for: state)\n✅ Parameters created for 1 geo-variable combinations.\n✅ Found 1 combinations. Building API queries...\nℹ️ Making 1 API call(s)...\nshape: (9, 5)\n┌─────────────────────────────────┬───────────┬──────┬────────────┬────────┐\n│                            NAME ┆         n ┆  pct ┆       cumn ┆ cumpct │\n╞═════════════════════════════════╪═══════════╪══════╪════════════╪════════╡\n│          Chicago city, Illinois ┆ 2,664,454 ┆ 10.9 ┆  2,664,454 ┆   10.9 │\n│              Dallas city, Texas ┆ 1,302,859 ┆  5.3 ┆  3,967,313 ┆   16.2 │\n│             Houston city, Texas ┆ 2,311,461 ┆  9.5 ┆  6,278,774 ┆   25.7 │\n│    Los Angeles city, California ┆ 3,820,963 ┆ 15.6 ┆ 10,099,737 ┆   41.3 │\n│         New York city, New York ┆ 8,258,035 ┆ 33.8 ┆ 18,357,772 ┆   75.1 │\n│ Philadelphia city, Pennsylvani… ┆ 1,550,542 ┆  6.3 ┆ 19,908,314 ┆   81.5 │\n│           Phoenix city, Arizona ┆ 1,650,051 ┆  6.8 ┆ 21,558,365 ┆   88.2 │\n│         San Antonio city, Texas ┆ 1,495,312 ┆  6.1 ┆ 23,053,677 ┆   94.3 │\n│      San Diego city, California ┆ 1,388,312 ┆  5.7 ┆ 24,441,989 ┆  100.0 │\n└─────────────────────────────────┴───────────┴──────┴────────────┴────────┘\n```\n:::\n:::\n\n\nHere we tabulate the cities with populations of 1M+ using the 2023 ACS 1-year estimates. Note that we don't include `NAME` in `set_variables()`--it's carried through because of `include_names=True`, and we can reference it in `tabulate()` and it will be included in our output data via the `to_*` methods.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}