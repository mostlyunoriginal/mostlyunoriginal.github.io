{
  "hash": "11fa49ba32c4f0fb5356b9e5bcb58198",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Decoupling Dynamic Code from a Static R Codebase\"\ndescription: \"Here we look at 2 ways to isolate the code that may change from the code that doesn't need to\"\ndate: 2025-03-20\nauthor:\n    - name: Lance Couzens\n      url: https://mostlyunoriginal.github.io  \ncategories: [R, Quality]\ncitation: \n  url: https://mostlyunoriginal.github.io/posts/2025-03-20-2-Options-Parameterizing-R-w-Code/\nimage: pReview.png\ndraft: false\n---\n\n\n\nOftentimes the best way to keep code working is to *just not touch it*. And while even the best, most stable code can't escape tweaking forever, there are some types of changes that can at least be made without even opening an otherwise stable and static codebase, assuming it's been set up to allow that.\n\nSuppose for example that we have an estimation pipeline that runs every year. In most years there are no changes to the methods or the structure of inputs/outputs, but every year there are some unavoidable changes to recode specifications. In this scenario, we have to be able to update the process but ideally in a way that minimizes both the effort required to QC the changes and the probability that something breaks. We can minimize the breakage potential by not opening the code at all, and we can minimize QC time by extracting only the affected code into a parameter file.\n\nHere are two ways to do that.\n\n# Option 1 - A Separate Script\n\nIn this option, we can store the recode logic in a separate R script. Here we define two new recodes, `cyl.rec` and `mpg.rec` based on the `mtcars` data frame. The rules are stored in vectors with each vector position containing, as strings, individual `case_when()` conditions and assignments.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\n#this part can exist in a separate script\nparms<-tribble(\n  ~newvar,     ~rules,\n  \"cyl.rec\",   c(\"cyl==4~1\",\"cyl==6~2\",\"cyl==8~3\"),\n  \"mpg.rec\",   c(\"mpg<15~'very bad'\",\"mpg<20~'bad'\",\"mpg<25~'good'\",\"TRUE~'very good'\")\n)\n```\n:::\n\n\n\nWe then have a static codebase that walks over the parameter file, creating recodes according to whatever code is found there.\n\nTo achieve this, we utilize `purrr::pwalk()` to iterate over the parameter file `parms`, applying for each row an anonymous function that creates the recode corresponding to that row.\n\nThe recode is created by injecting `parms$newvar` as the new variable name, and splicing (via `!!!`) the vector of conditions from `parms$rules` into the body of `case_when()`. Notably, for each iteration, `cars` is read in from the global environment, the recode is created, and `cars` is written to the global environment. Alternatively, we could create within the function body a data frame containing only the newly-defined column, capture them across iterations in a list (using `purrr::pmap()` instead of `purrr::pwalk()`) and column bind the list along with `cars`. I've done it both ways, but I prefer the global environment overwrite approach used below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#this part represents a static codebase that would follow a source() call \n# to the parameter file-generating script\n\ncars<-mtcars %>%\n  rownames_to_column(\"car\")\n\npwalk(\n  parms\n  ,function(newvar,rules,df=cars){\n\n    df.name<-deparse(substitute(df))\n    \n    df %>%\n      mutate(!!newvar:=case_when(!!!rlang::parse_exprs(rules))) %>% \n      assign(df.name,.,envir=globalenv())\n    \n  }\n)\n\nselect(cars,car,cyl,cyl.rec,mpg,mpg.rec)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                   car cyl cyl.rec  mpg   mpg.rec\n1            Mazda RX4   6       2 21.0      good\n2        Mazda RX4 Wag   6       2 21.0      good\n3           Datsun 710   4       1 22.8      good\n4       Hornet 4 Drive   6       2 21.4      good\n5    Hornet Sportabout   8       3 18.7       bad\n6              Valiant   6       2 18.1       bad\n7           Duster 360   8       3 14.3  very bad\n8            Merc 240D   4       1 24.4      good\n9             Merc 230   4       1 22.8      good\n10            Merc 280   6       2 19.2       bad\n11           Merc 280C   6       2 17.8       bad\n12          Merc 450SE   8       3 16.4       bad\n13          Merc 450SL   8       3 17.3       bad\n14         Merc 450SLC   8       3 15.2       bad\n15  Cadillac Fleetwood   8       3 10.4  very bad\n16 Lincoln Continental   8       3 10.4  very bad\n17   Chrysler Imperial   8       3 14.7  very bad\n18            Fiat 128   4       1 32.4 very good\n19         Honda Civic   4       1 30.4 very good\n20      Toyota Corolla   4       1 33.9 very good\n21       Toyota Corona   4       1 21.5      good\n22    Dodge Challenger   8       3 15.5       bad\n23         AMC Javelin   8       3 15.2       bad\n24          Camaro Z28   8       3 13.3  very bad\n25    Pontiac Firebird   8       3 19.2       bad\n26           Fiat X1-9   4       1 27.3 very good\n27       Porsche 914-2   4       1 26.0 very good\n28        Lotus Europa   4       1 30.4 very good\n29      Ford Pantera L   8       3 15.8       bad\n30        Ferrari Dino   6       2 19.7       bad\n31       Maserati Bora   8       3 15.0       bad\n32          Volvo 142E   4       1 21.4      good\n```\n\n\n:::\n:::\n\n\n\n# Option 2 - Code Stored as Text in a Separate File (like a csv)\n\nOption 2 does the same thing---creating recodes metaprogrammatically by storing the code as data---but may be a better fit if we want to store the code in text-based, tabular format rather than in an R script. This can be useful, for example, if we want someone who is a subject-matter expert but not an R programmer to write or review the recode code (in this case we could even break down the conditions in the parameter file further to strip out the `case_when()` syntax and reassemble as necessary in the static codebase).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#this part can exist in .csv or .xlsx file\nparms.alt<-tribble(\n  ~newvar,     ~rules,\n  \"cyl.rec\",   \"cyl==4~1\",\n  \"cyl.rec\",   \"cyl==6~2\",\n  \"cyl.rec\",   \"cyl==8~3\",\n  \"mpg.rec\",   \"mpg<15~'very bad'\",\n  \"mpg.rec\",   \"mpg<20~'bad'\",\n  \"mpg.rec\",   \"mpg<25~'good'\",\n  \"mpg.rec\",   \"TRUE~'very good'\"\n) \n```\n:::\n\n\n\nThe main difference on the static codebase side is that we group the parameter file by `newvar` and use `group_walk()` to apply our anonymous function after extracting the `rules` vector manually.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#this part represents a static codebase that would follow an ingestion step\n# that reads in the parameter file from wherever it's stored\n\ncars<-mtcars %>%\n  rownames_to_column(\"car\")\n\nparms.alt %>%\n  group_by(newvar) %>%\n  group_walk(\n    function(rules,group,df=cars){\n      \n      df.name<-deparse(substitute(df))\n      \n      newvar<-pull(group,newvar)\n      rules<-pull(rules,rules)\n\n      df %>%\n        mutate(!!newvar:=case_when(!!!rlang::parse_exprs(rules))) %>%\n        assign(df.name,.,envir=globalenv())\n      \n    }\n  )\n\nselect(cars,car,cyl,cyl.rec,mpg,mpg.rec)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                   car cyl cyl.rec  mpg   mpg.rec\n1            Mazda RX4   6       2 21.0      good\n2        Mazda RX4 Wag   6       2 21.0      good\n3           Datsun 710   4       1 22.8      good\n4       Hornet 4 Drive   6       2 21.4      good\n5    Hornet Sportabout   8       3 18.7       bad\n6              Valiant   6       2 18.1       bad\n7           Duster 360   8       3 14.3  very bad\n8            Merc 240D   4       1 24.4      good\n9             Merc 230   4       1 22.8      good\n10            Merc 280   6       2 19.2       bad\n11           Merc 280C   6       2 17.8       bad\n12          Merc 450SE   8       3 16.4       bad\n13          Merc 450SL   8       3 17.3       bad\n14         Merc 450SLC   8       3 15.2       bad\n15  Cadillac Fleetwood   8       3 10.4  very bad\n16 Lincoln Continental   8       3 10.4  very bad\n17   Chrysler Imperial   8       3 14.7  very bad\n18            Fiat 128   4       1 32.4 very good\n19         Honda Civic   4       1 30.4 very good\n20      Toyota Corolla   4       1 33.9 very good\n21       Toyota Corona   4       1 21.5      good\n22    Dodge Challenger   8       3 15.5       bad\n23         AMC Javelin   8       3 15.2       bad\n24          Camaro Z28   8       3 13.3  very bad\n25    Pontiac Firebird   8       3 19.2       bad\n26           Fiat X1-9   4       1 27.3 very good\n27       Porsche 914-2   4       1 26.0 very good\n28        Lotus Europa   4       1 30.4 very good\n29      Ford Pantera L   8       3 15.8       bad\n30        Ferrari Dino   6       2 19.7       bad\n31       Maserati Bora   8       3 15.0       bad\n32          Volvo 142E   4       1 21.4      good\n```\n\n\n:::\n:::\n\n\n\n------------------------------------------------------------------------\n\nIn either case, the recode changes are easy to QC and we eliminate the chance that we could break stable code by not even having to open it.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}