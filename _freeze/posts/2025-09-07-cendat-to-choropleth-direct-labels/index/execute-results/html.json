{
  "hash": "a3a79ecbf10360342895c65ad6c42549",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Choropleths from Census Data Pt. 2\"\ndescription: \"An updated mockup with direct labelling\"\ndate: 2025-09-07\nauthor:\n    - name: Lance Couzens\n      url: https://mostlyunoriginal.github.io  \ncategories: [Python, cendat, Census, API, choropleth maps]\ncitation: \n  url: https://mostlyunoriginal.github.io/posts/2025-09-07-cendat-to-choropleth-direct-labels/\nimage: logo.png \ndraft: false\nlightbox: true\n---\n\n# A Preference for Direct Labels\n\nAs covered in yesterday's post, I've got all the pieces I need to add choropleth map functionality to `cendat`–now I just need to put them all together. My biggest complaint about yesterday's first attempt was the way the base map labels degrade because they're raster graphics that you can only zoom in on. I speculated that it would probably be better to just plot labels directly, and that's what's covered here.\n\n### Place and (some) County Subdivision Centroids\n\nIn order to make it easy for users to orient themselves in choropleth maps, they need labels for cities, towns, etc. Depending on where you are in the U.S., that could imply incorporated places or a mix of incorporated places and county subdivisions (in some states, county subdivision areas represent official government entities, often called townships).\n\nTo label these entities, we need their names and the latitudes and longitudes representing their centroids. Thankfully, I can easily get that for all U.S. incorporated places and (meaningful) county subdivisions with single queries to the TIGERweb REST Service. Since this will be done within a new method of the `CenDatResponse` class, I will make sure to update `CenDatHelper.get_data` to pass the appropriate map server and layer IDs to the response object. But, once I have that, it's a pretty straight-forward addition. The following continues the example started in yesterday's post.\n\n### Get Places and County Subs Simultaneously in a 2-Worker Thread Pool\n\n::: {#c4d352c0 .cell execution_count=1}\n``` {.python .cell-code}\n%%time\n\nfrom concurrent.futures import ThreadPoolExecutor\nimport geopandas as gpd\nimport pandas as pd\nimport requests\nfrom collections import defaultdict\nimport matplotlib.pyplot as plt\nimport os\nfrom cendat import CenDatHelper\nimport contextily as ctx\n\ngeo_data = defaultdict(gpd.GeoDataFrame)\n\ndef get_tiger_polygons(\n    layer_id: int,\n    where_clause: str,\n    fields: str,\n    service: str = \"TIGERweb/tigerWMS_Current\",\n) -> gpd.GeoDataFrame:\n\n    API_URL = (\n        \"https://tigerweb.geo.census.gov/arcgis/rest/\"\n        f\"services/{service}/MapServer/{layer_id}/query\"\n    )\n\n    params = {\n        \"where\": where_clause,\n        \"outFields\": fields,\n        \"outSR\": \"4326\",\n        \"f\": \"geojson\",\n        \"returnGeometry\": \"false\",\n        \"returnCountOnly\": \"false\",\n        \"resultOffset\": 0,\n        \"resultRecordCount\": 100_000,\n        \"timeout\": 60,\n    }\n\n    try:\n        response = requests.get(API_URL, params=params)\n        response.raise_for_status()\n        geo_data[layer_id] = gpd.GeoDataFrame.from_features(response.json()[\"features\"])\n        print(f\"✅ Successfully fetched {len(geo_data[layer_id])} centroids.\")\n\n    except requests.exceptions.RequestException as e:\n        print(f\"❌ HTTP Request failed: {e}\")\n    except (KeyError, ValueError) as e:\n        print(f\"❌ Failed to parse response JSON: {e}\")\n        print(f\"   Server Response: {response.text[:200]}...\")\n\n\ntry:\n    with ThreadPoolExecutor(max_workers=2) as executor:\n\n        future_places = executor.submit(\n            get_tiger_polygons, 28, \"1=1\", \"STATE,NAME,AREALAND,CENTLAT,CENTLON\"\n        )\n        future_countysubs = executor.submit(\n            get_tiger_polygons,\n            22,\n            (\n                \"NAME LIKE '%township' OR \"\n                \"NAME LIKE '%town' OR \"\n                \"NAME LIKE '%village' OR \"\n                \"NAME LIKE '%borough'\"\n            ),\n            \"STATE,NAME,AREALAND,CENTLAT,CENTLON\",\n        )\n\n        future_places.result()\n        future_countysubs.result()\n\nexcept Exception as exc:\n    print(f\"❌ A master fetching task failed: {exc}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n✅ Successfully fetched 19733 centroids.\n✅ Successfully fetched 23060 centroids.\nCPU times: user 295 ms, sys: 60.3 ms, total: 355 ms\nWall time: 3.63 s\n```\n:::\n:::\n\n\nHere we've used a generic function to fetch geography centroids, separately parameterized for places and county subs, in a thread pool, updating the `geo_data` dictionary as the data come in.\n\n### Clean up Centroids and Get Income Estimates\n\n::: {#249569c4 .cell execution_count=2}\n``` {.python .cell-code}\nstacked = pd.concat(geo_data.values(), ignore_index=True)\nstacked[\"AREALAND\"] = stacked[\"AREALAND\"].astype(int)\nstacked[\"CENTLAT\"] = stacked[\"CENTLAT\"].astype(float)\nstacked[\"CENTLON\"] = stacked[\"CENTLON\"].astype(float)\nstacked[\"NCILE\"] = stacked.groupby(\"STATE\")[\"AREALAND\"].transform(\n    lambda x: pd.qcut(x, 20, labels=False, duplicates=\"drop\") + 1\n)\n\ncdh = CenDatHelper(key=os.getenv(\"CENSUS_API_KEY\"))\n\ncdh.list_products(years=[2023], patterns=r\"acs/acs5\\)\")\ncdh.set_products()\ncdh.set_groups([\"B19013\"])\ncdh.set_geos([\"150\"])\nresponse = cdh.get_data(\n    include_names=True,\n    include_geometry=True,\n    within={\n        \"state\": [\n            \"08\",\n        ],\n        \"county\": [\"069\", \"123\", \"013\"],\n    },\n)\n```\n:::\n\n\nThe latitude and longitude data come in as strings, so we need to convert those. We've also pulled the overall land area for our geographies, which we use (after converting to numeric) to create the rank groups variable `NCILE`. We'll use this to filter down to the areas we want to label based on their area size.\n\n### Plot\n\nThis builds directly off what we had yesterday, except I only use the unlabeled base map, adding labels directly from our centroids data.\n\n::: {#90163d1a .cell execution_count=3}\n``` {.python .cell-code}\ncutoff = 19\n\ngdf = response.to_gpd(destring=True, join_strategy=\"inner\")\ngdf.loc[gdf[\"B19013_001E\"] == -666666666, \"B19013_001E\"] = None\n\nfig, ax = plt.subplots(1, 1, figsize=(10, 6), dpi=300)\n\ngdf.plot(\n    column=\"B19013_001E\",\n    cmap=\"viridis\",\n    linewidth=0.3,\n    edgecolor=\"black\",\n    ax=ax,\n    legend=True,\n    alpha=0.8,\n    legend_kwds={\n        \"label\": \"Income\",\n        \"orientation\": \"horizontal\",\n        \"location\": \"bottom\",\n        \"shrink\": 0.5,\n        \"fraction\": 0.1,\n        \"format\": \"{x:,.0f}\",\n        \"alpha\": 0.8,\n        \"pad\": 0.1,\n    },\n    missing_kwds={\n        \"color\": \"lightgrey\",\n        \"edgecolor\": \"grey\",\n        \"hatch\": \"////\",\n        \"label\": \"Missing values\",\n    },\n)\n\nxmin, xmax = ax.get_xlim()\nymin, ymax = ax.get_ylim()\n\nvisible_centroids = stacked[\n    (stacked[\"CENTLON\"] >= xmin)\n    & (stacked[\"CENTLON\"] <= xmax)\n    & (stacked[\"CENTLAT\"] >= ymin)\n    & (stacked[\"CENTLAT\"] <= ymax)\n    & (stacked[\"NCILE\"] >= cutoff)\n]\n\nax.scatter(\n    visible_centroids[\"CENTLON\"],\n    visible_centroids[\"CENTLAT\"],\n    s=10,  \n    c=\"black\",  \n    edgecolor=\"white\",\n    zorder=2,  \n    alpha=0.8,\n)\n\ny_offset = 0.015\n\nfor idx, row in visible_centroids.iterrows():\n    ax.text(\n        x=row[\"CENTLON\"],\n        y=row[\"CENTLAT\"] + y_offset,\n        s=row[\"NAME\"],\n        fontsize=max(3, 9 * (row[\"NCILE\"] ** (cutoff / 4) / 20 ** (cutoff / 4))),\n        fontweight=\"light\",\n        ha=\"center\",\n        va=\"bottom\",\n        zorder=3,\n        bbox=dict(\n            boxstyle=\"round,pad=0.1,rounding_size=0.2\",\n            fc=\"white\",\n            ec=\"none\",\n            alpha=0.7,\n        ),\n    )\n\nctx.add_basemap(\n    ax,\n    source=ctx.providers.CartoDB.PositronNoLabels,\n    attribution=False,\n    zoom=10,\n    crs=4326,\n    alpha=1.0,\n)\n\nax.set_title(\n    \"Larimer, Weld, and Boulder County Med. HH Income by block group\",\n    fontdict={\"fontsize\": \"16\", \"fontweight\": \"3\"},\n)\nax.set_axis_off()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-4-output-1.png){}\n:::\n:::\n\n\nI like this *so* much more! And, while it's very difficult to avoid overlapping labels in a generalized context, I actually don't mind them here. These plots are intended to have analytic utility, not really to be publication ready, and the combination of the white label backgrounds and transparency level makes them both useful and not too visually cluttered.\n\n",
    "supporting": [
      "index_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}