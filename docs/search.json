[
  {
    "objectID": "posts/2025-03-19-R-v-Python-Compute-Time-Ex/index.html",
    "href": "posts/2025-03-19-R-v-Python-Compute-Time-Ex/index.html",
    "title": "R vs. Python Query Compute Time Example",
    "section": "",
    "text": "Let’s compare the compute time needed for an equivalent operation between Python and R. The operation is to:\nIn Python, we will use polars with lazy evaluation. In R, we will use dplyr, dtplyr, and tidytable. The latter two packages interpret dplyr syntax and deploy the data.table equivalent for efficiency."
  },
  {
    "objectID": "posts/2025-03-19-R-v-Python-Compute-Time-Ex/index.html#plain-dplyr",
    "href": "posts/2025-03-19-R-v-Python-Compute-Time-Ex/index.html#plain-dplyr",
    "title": "R vs. Python Query Compute Time Example",
    "section": "Plain dplyr",
    "text": "Plain dplyr\n\nlibrary(tidyverse)\nlibrary(hms)\n\n\nAttaching package: 'hms'\n\n\nThe following object is masked from 'package:lubridate':\n\n    hms\n\nstart&lt;-Sys.time()\n\nrows&lt;-data.table::fread(\"big.csv\") %&gt;%\n  group_by(id) %&gt;%\n  summarize(across(where(is.double),mean),.groups=\"keep\") %&gt;%\n  filter(if_any(where(is.double),~.x&gt;.4)) %&gt;%\n  nrow()\n\nend&lt;-Sys.time()\n\nprint(str_glue(\"{rows} rows returned\\nelapsed time for query: {as_hms(end-start)}\"))\n\n324 rows returned\nelapsed time for query: 00:02:08.925837"
  },
  {
    "objectID": "posts/2025-03-19-R-v-Python-Compute-Time-Ex/index.html#dtplyr",
    "href": "posts/2025-03-19-R-v-Python-Compute-Time-Ex/index.html#dtplyr",
    "title": "R vs. Python Query Compute Time Example",
    "section": "dtplyr",
    "text": "dtplyr\nThis is stylistically the R version that is most similar to the polars approach, but it does come with some downsides in that not all dplyr functionality is supported. In this example that is most obvious in the inability to use tidyselect helpers in summarize() and filter().\n\nlibrary(dtplyr,warn.conflicts=F)\n\nstart&lt;-Sys.time()\n\nbig&lt;-data.table::fread(\"big.csv\")\n\nvarnames&lt;-setdiff(colnames(big),\"id\")\n\nrows&lt;-lazy_dt(big) %&gt;%\n  group_by(id) %&gt;%\n  summarize(across(all_of(varnames),mean),.groups=\"keep\") %&gt;%\n  filter(if_any(all_of(varnames),~.x&gt;.4)) %&gt;%\n  collect() %&gt;%\n  nrow()\n\nend&lt;-Sys.time()\n\nprint(str_glue(\"{rows} rows returned\\nelapsed time for query: {as_hms(end-start)}\"))\n\n324 rows returned\nelapsed time for query: 00:00:44.920429"
  },
  {
    "objectID": "posts/2025-03-19-R-v-Python-Compute-Time-Ex/index.html#tidytable",
    "href": "posts/2025-03-19-R-v-Python-Compute-Time-Ex/index.html#tidytable",
    "title": "R vs. Python Query Compute Time Example",
    "section": "tidytable",
    "text": "tidytable\nThis should be computationally comparable to the dtplyr approach as both are deploying data.table behind the scenes, but this approach has the benefit of preserving the plain dplyr syntax, including the ability to use tidyselect helpers.\n\nstart&lt;-Sys.time()\n\nrows&lt;-data.table::fread(\"big.csv\") %&gt;%\n  tidytable::group_by(id) %&gt;%\n  tidytable::summarize(tidytable::across(where(is.double),mean),.groups=\"keep\") %&gt;%\n  tidytable::filter(tidytable::if_any(where(is.double),~.x&gt;.4)) %&gt;%\n  nrow()\n\nend&lt;-Sys.time()\n\nprint(str_glue(\"{rows} rows returned\\nelapsed time for query: {as_hms(end-start)}\"))\n\n324 rows returned\nelapsed time for query: 00:00:57.015057"
  }
]